.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "librrd 3"
.TH librrd 3 "2009-11-15" "1.4.7" "rrdtool"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
librrd \- RRD library functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBlibrrd\fR contains most of the functionality in \fBRRDTool\fR.  The command
line utilities and language bindings are often just wrappers around the
code contained in \fBlibrrd\fR.
.PP
This manual page documents the \fBlibrrd\fR \s-1API\s0.
.PP
\&\fB\s-1NOTE:\s0\fR This document is a work in progress, and should be considered
incomplete as long as this warning persists.  For more information about
the \fBlibrrd\fR functions, always consult the source code.
.SH "CORE FUNCTIONS"
.IX Header "CORE FUNCTIONS"
.IP "\fBrrd_dump_cb_r(char *filename, int opt_header, rrd_output_callback_t cb, void *user)\fR" 4
.IX Item "rrd_dump_cb_r(char *filename, int opt_header, rrd_output_callback_t cb, void *user)"
In some situations it is necessary to get the output of \f(CW\*(C`rrd_dump\*(C'\fR without
writing it to a file or the standard output. In such cases an application
can ask \fBrrd_dump_cb_r\fR to call an user-defined function each time there
is output to be stored somewhere. This can be used, to e.g. directly feed
an \s-1XML\s0 parser with the dumped output or transfer the resulting string
in memory.
.Sp
The arguments for \fBrrd_dump_cb_r\fR are the same as for \fBrrd_dump_opt_r\fR
except that the output filename parameter is replaced by the user-defined
callback function and an additional parameter for the callback function
that is passed untouched, i.e. to store information about the callback state
needed for the user-defined callback to function properly.
.Sp
Recent versions of \fBrrd_dump_opt_r\fR internally use this callback mechanism
to write their output to the file provided by the user.
.Sp
.Vb 7
\&    size_t rrd_dump_opt_cb_fileout(
\&        const void *data,
\&        size_t len,
\&        void *user)
\&    {
\&        return fwrite(data, 1, len, (FILE *)user);
\&    }
.Ve
.Sp
The associated call for \fBrrd_dump_cb_r\fR looks like
.Sp
.Vb 2
\&    res = rrd_dump_cb_r(filename, opt_header,
\&        rrd_dump_opt_cb_fileout, (void *)out_file);
.Ve
.Sp
where the last parameter specifies the file handle \fBrrd_dump_opt_cb_fileout\fR
should write to. There's no specific condition for the callback to detect
when it is called for the first time, nor for the last time. If you require
this for initialization and cleanup you should do those tasks before and
after calling \fBrrd_dump_cr_r\fR respectively.
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
.IP "\fB\f(BIrrd_random()\fB\fR" 4
.IX Item "rrd_random()"
Generates random numbers just like \fIrandom()\fR.  This further ensures that
the random number generator is seeded exactly once per process.
.IP "\fBrrd_add_ptr(void ***dest, size_t *dest_size, void *src)\fR" 4
.IX Item "rrd_add_ptr(void ***dest, size_t *dest_size, void *src)"
Dynamically resize the array pointed to by \f(CW\*(C`dest\*(C'\fR.  \f(CW\*(C`dest_size\*(C'\fR is a
pointer to the current size of \f(CW\*(C`dest\*(C'\fR.  Upon successful \fIrealloc()\fR, the
\&\f(CW\*(C`dest_size\*(C'\fR is incremented by 1 and the \f(CW\*(C`src\*(C'\fR pointer is stored at the
end of the new \f(CW\*(C`dest\*(C'\fR.  Returns 1 on success, 0 on failure.
.Sp
.Vb 5
\&    type **arr = NULL;
\&    type *elem = "whatever";
\&    size_t arr_size = 0;
\&    if (!rrd_add_ptr(&arr, &arr_size, elem))
\&        handle_failure();
.Ve
.IP "\fBrrd_add_strdup(char ***dest, size_t *dest_size, char *src)\fR" 4
.IX Item "rrd_add_strdup(char ***dest, size_t *dest_size, char *src)"
Like \f(CW\*(C`rrd_add_ptr\*(C'\fR, except adds a \f(CW\*(C`strdup\*(C'\fR of the source string.
.Sp
.Vb 5
\&    char **arr = NULL;
\&    size_t arr_size = NULL;
\&    char *str  = "example text";
\&    if (!rrd_add_strdup(&arr, &arr_size, str))
\&        handle_failure();
.Ve
.IP "\fBrrd_free_ptrs(void ***src, size_t *cnt)\fR" 4
.IX Item "rrd_free_ptrs(void ***src, size_t *cnt)"
Free an array of pointers allocated by \f(CW\*(C`rrd_add_ptr\*(C'\fR or
\&\f(CW\*(C`rrd_add_strdup\*(C'\fR.  Also frees the array pointer itself.  On return, the
source pointer will be \s-1NULL\s0 and the count will be zero.
.Sp
.Vb 3
\&    /* created as above */
\&    rrd_free_ptrs(&arr, &arr_size);
\&    /* here, arr == NULL && arr_size == 0 */
.Ve
.IP "\fBrrd_mkdir_p(const char *pathname, mode_t mode)\fR" 4
.IX Item "rrd_mkdir_p(const char *pathname, mode_t mode)"
Create the directory named \f(CW\*(C`pathname\*(C'\fR including all of its parent
directories (similar to \f(CW\*(C`mkdir \-p\*(C'\fR on the command line \- see \fImkdir\fR\|(1) for
more information). The argument \f(CW\*(C`mode\*(C'\fR specifies the permissions to use. It
is modified by the process's \f(CW\*(C`umask\*(C'\fR. See \fImkdir\fR\|(2) for more details.
.Sp
The function returns 0 on success, a negative value else. In case of an error,
\&\f(CW\*(C`errno\*(C'\fR is set accordingly. Aside from the errors documented in \fImkdir\fR\|(2),
the function may fail with the following errors:
.RS 4
.IP "\fB\s-1EINVAL\s0\fR" 4
.IX Item "EINVAL"
\&\f(CW\*(C`pathname\*(C'\fR is \f(CW\*(C`NULL\*(C'\fR or the empty string.
.IP "\fB\s-1ENOMEM\s0\fR" 4
.IX Item "ENOMEM"
Insufficient memory was available.
.IP "\fBany error returned by \f(BIstat\fB\|(2)\fR" 4
.IX Item "any error returned by stat"
.RE
.RS 4
.Sp
In contrast to \fImkdir\fR\|(2), the function does \fBnot\fR fail if \f(CW\*(C`pathname\*(C'\fR
already exists and is a directory.
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1RRD\s0 Contributors <rrd\-developers@lists.oetiker.ch>
